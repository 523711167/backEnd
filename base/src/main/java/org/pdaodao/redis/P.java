package org.pdaodao.redis;


/**
 *  redis
 *      1。redis效率高的原因
 *          1。redis是基于内存的
 *          2。redis处理来自客户端的任务是单线程的。
 *          3。基于NIO多路复用的epoll网络模型
 *              什么是NIO,BIO
 *              BIO：用户通过系统调用内核数据，内核暂无数据，线程阻塞，直到内核返回数据。
 *              NIO：用户通过系统调用内核数据，如果有数据，内核立即返回，否则内核返回空数据
 *              等待下次系统调用
 *              非多路复用：每个线程负责通过系统调用获取内核数据
 *              多路复用：单个线程监听多个fd,遍历fd集合通过系统调用获取内核数据
 *              epoll 多路复用的一种实现 select poll
 *              服务端通过create系统调用创建监听的fd红黑树和就绪fd状态的链表，每当客户端
 *              连接，就会调用ctl向红黑树中注册需要监听fd,之后调用wait命令等待就绪的fd,
 *              当客户端发送命令请求， 根据客户端fd直接系统调用，结果写入链表把结果拷贝到用户空间。
 *
 *      2。Redis 为什么是单线程的？
 *          1.redis的瓶颈主要是来自内存和网络带宽,不需要设计成多线程处理任务。
 *      3。redis故障
 *          1。缓存穿透
 *              解释：reids和数据库都查询不到数据
 *              处理办法：设置对应key为空的value
 *          2。缓存击穿
 *              解释：短时间内大量请求查询数据，某个Key突然过期，构建缓存期间，大量查询数据库
 *              处理办法：过期时间拉长，动态更新过期时间
 *          3。缓存雪崩
 *              解释：短时间大量请求，大量key同一时间过期，构建缓存期间，数据库压力增大
 *              处理办法：设置多级缓存，过期时间拉长
*        4。redis持久化方案
 *          Aof: 把每个redis命令写入文本
 *          rdb：指定时间间隔对数据进行备份
 *       5。redis实现分布式锁
 *          1.生成全局唯一的UUID
 *          2.利用reids的setnx命令 key在不存在的时候设置返回true
 *             key已经存在设置为false,通过返回值判断是否获取锁成功
 *          3.业务处理完成之后删除锁
 *
 */
public interface P {
}
